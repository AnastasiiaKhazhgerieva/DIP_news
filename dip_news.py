# -*- coding: utf-8 -*-
"""dip_news.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/17KKwbfVuL28SPhRasyS-FeUXLvmP2PNo
"""

# packages

import requests
import json
import time
import datetime
import os
import pandas as pd
import google.generativeai as genai
import io
try: # google colab не запускается, когда раним через workflow, он там есть по умолчанию, поэтому имени в PyPL такого нет
    from google.colab import userdata, drive
except ImportError:
    userdata = None
    drive = None
from datetime import date, timedelta, datetime
from typing import List
from bs4 import BeautifulSoup
from urllib.parse import urljoin, urlparse
from google.oauth2.service_account import Credentials
from googleapiclient.discovery import build
from googleapiclient.errors import HttpError
from googleapiclient.http import MediaIoBaseDownload, MediaIoBaseUpload

# Auxilliary
HEADERS = {"User-Agent": "Mozilla/5.0"}

# service account credentials (to access google drive)
sa_json = os.environ.get("GCP_SA_KEY") # строка для запуска через workflow
#with open("hybrid-sunbeam-461621-s8-9191b51ccff5.json", 'r', encoding='utf-8') as f: # для локального запуска
#   sa_json = f.read()  # для локального запуска
if not sa_json:
    raise RuntimeError("Сервисный аккаунт не найден")

creds_info = json.loads(sa_json)

creds = Credentials.from_service_account_info(
    creds_info,
    scopes=["https://www.googleapis.com/auth/drive"]
)
drive_service = build("drive", "v3", credentials=creds)

MY_FOLDER_ID = "1BwBFMln6HcGUfBFN4-UlNueOTKUehiRe" # папка reports на google drive

# gemini api key
API_KEY = os.environ.get("GEMINI_API_KEY") # строка для запуска через workflow
#API_KEY = userdata.get('gemini_api_key') # строка для локального запуска
genai.configure(api_key=API_KEY)
model_obj = genai.GenerativeModel('gemini-1.5-flash')

### Functions for google drive

def find_file_in_drive(file_name: str, folder_id = "1BwBFMln6HcGUfBFN4-UlNueOTKUehiRe") -> str:
    try:
        resp = drive_service.files().list(
            q=(
                f"name = '{file_name}' "
                f"and '{folder_id}' in parents "
                f"and trashed = false"
            ),
            spaces="drive",
            fields="files(id, name)",
            pageSize=1
        ).execute()
    except HttpError as e:
        raise RuntimeError(f"Error accessing Drive API: {e}")

    items = resp.get("files", [])
    if items:
        return items[0]["id"]

    raise FileNotFoundError(f"File '{file_name}' not found in folder {folder_id}.")

def download_text_file(fid: str) -> str:
    request = drive_service.files().get_media(fileId=fid)
    fh = io.BytesIO()
    downloader = MediaIoBaseDownload(fh, request)
    done = False
    while not done:
        status, done = downloader.next_chunk()
    return fh.getvalue().decode("utf-8")

def save_to_drive(file_name: str, data, my_folder = MY_FOLDER_ID):

    if isinstance(data, str):
        # save as plain text
        content_bytes = data.encode("utf-8")
        mime_type = "text/plain"
    else:
        # as JSON
        json_str = json.dumps(data, ensure_ascii=False, indent=2)
        content_bytes = json_str.encode("utf-8")
        mime_type = "application/json"

    existing_file_id = None
    try:
        resp = drive_service.files().list(
            q=f"name = '{file_name}' and '{my_folder}' in parents and trashed = false",
            spaces="drive",
            fields="files(id, name)",
            pageSize=1
        ).execute()
        items = resp.get("files", [])
        if items:
            existing_file_id = items[0]["id"]
    except Exception as e:
        print("Warning: can't check, if the file already exists:", e)

    fh = io.BytesIO(content_bytes)
    media = MediaIoBaseUpload(fh, mimetype=mime_type, resumable=False)

    if existing_file_id:
        # then rewrite
        try:
            updated = drive_service.files().update(
                fileId=existing_file_id,
                media_body=media
            ).execute()
            print(f"File '{file_name}' updated (ID={updated['id']}).")
            return updated
        except Exception as e:
            print(f"Error updating file '{file_name}': {e}")
            raise
    else:
        # then create
        file_metadata = {
            "name": file_name,
            "parents": [my_folder],
            "mimeType": mime_type
        }
        try:
            created = drive_service.files().create(
                body=file_metadata,
                media_body=media,
                fields="id, webViewLink"
            ).execute()
            print(f"New file created: '{file_name}', (ID={created['id']}).")
            return created
        except Exception as e:
            print(f"Error creating a new file '{file_name}': {e}")
            raise



### Prompts

#file_path = '/content/drive/MyDrive/news lists, prompt beginning.txt'

file_id = find_file_in_drive("news lists, prompt beginning.txt", "1N7-qRmFebMzij2yR3nm7Edp6Hoayva-V")

try:
    prompt_list_start = download_text_file(file_id)
except Exception as e:
    print("Ошибка при скачивании файла:", e)
    prompt_list_start = ""

#try:
#    with open(file_path, 'r', encoding='utf-8') as f:
#        propmt_list_start = f.read()
#except FileNotFoundError:
#    print(f"Error: no file found (path: {file_path})")
#except Exception as e:
#    print(f"Error while reading file: {e}")

file_id = find_file_in_drive("bullets, prompt beginning.txt","1N7-qRmFebMzij2yR3nm7Edp6Hoayva-V")

try:
    prompt_bullets_start = download_text_file(file_id)
except Exception as e:
    print("Ошибка при скачивании файла:", e)
    prompt_bullets_start = ""

#try:
#    with open(file_path, 'r', encoding='utf-8') as f:
#        prompt_bullets_start = f.read()
#except FileNotFoundError:
#    print(f"Error: no file found (path: {file_path})")
#except Exception as e:
#    print(f"Error while reading file: {e}")

section_to_continue_prompt = {
    "world": [
        'Пожалуйста, просмотри АБСОЛЮТНО ВСЕ НОВОСТИ в приложенном файле и отбери из них только те, что СТРОГО соответствуют критериям и могут быть включены в нумерованный список для раздела по мировой экономике.'
    ],
    "rus": [
        'Пожалуйста, просмотри АБСОЛЮТНО ВСЕ НОВОСТИ в приложенном файле и отбери из них только те, что СТРОГО соответствуют критериям и могут быть включены в нумерованный список для раздела по россиийской экономике.'
    ],
    "prices": [
        'Пожалуйста, просмотри АБСОЛЮТНО ВСЕ НОВОСТИ в приложенном файле и отбери из них только те, что СТРОГО соответствуют критериям и могут быть включены в нумерованный список для раздела по новостям, релевантным для динамики российских цен.'
    ]
}
prompt_list_finish = 'Пришли мне текстовый файл с нумерованным списком новостей, СТРОГО соответствующих требованиям. Оформи нумерованный список так: новость, ниже ее URL, прикладываю пример оформления. ОЧЕНЬ ВАЖНО: В ОТВЕТ НЕ ПРИСЫЛАЙ НИЧЕГО КРОМЕ ТЕКСТОВОГО ФАЙЛА.'

section_to_finish_bullets_prompt = {
    "world": [
        'Пожалуйста, подготовь 3 буллита для раздела по мировой экономике в соответствии с требованиями и пришли только буллиты и больше никакого текста.'
    ],
    "rus": [
        'Пожалуйста, подготовь 3 буллита для раздела по россиийской экономике в соответствии с требованиями и пришли только буллиты и больше никакого текста.'
    ],
    "prices": [
        'Пожалуйста, подготовь 3 буллита для раздела по новостям, релевантным для динамики российских цен, в соответствии с требованиями и пришли только буллиты и больше никакого текста.'
    ]
}

prompt_prioritise = 'Пожалуйста, оставь в разделе не более 30 наиболее новостей, в наибольшей степени подходящих под критерии. Пришли итоговый результат текстом в виде списка. НИКАК НЕ ИЗМЕНЯЙ ССЫЛКИ ИЛИ НАЗВАНИЯ НОВОСТЕЙ.'

example = 'Пример верного оформления:\r\n1.\tРосстат зафиксировал стабилизацию выпуска базовых отраслей\r\nhttps://www.kommersant.ru/doc/7329366 \r\n2.\tСтроители просят смягчить правила распоряжения авансами\r\nhttps://www.rbc.ru/newspaper/2024/11/25/673f6abf9a7947de58a24847 \r\n3.\tВ Ульяновске открылся новый завод грузовиков Соллерс\r\nhttps://tass.ru/ekonomika/22497349 \r\n4.\t Добыча газа за 9 месяцев выросла на 8% г/г в основном за счет Газпрома\r\nhttps://www.interfax.ru/business/994801 \r\n'



def create_bullets(section):

    MY_FOLDER_ID = "1BwBFMln6HcGUfBFN4-UlNueOTKUehiRe"

    list_file = f"{section}.txt"
    file_id = find_file_in_drive(list_file)

    try:
        list_content = download_text_file(file_id)
    except Exception as e:
        print("Ошибка при скачивании файла:", e)

    # Берём соответствующий prompt для завершения
    prompt_bullets_finish = section_to_finish_bullets_prompt[section]

    # Формируем prompt_parts
    raw_parts = [
        prompt_bullets_start,
        prompt_bullets_finish,
        list_content
    ]

    prompt_parts = []
    for part in raw_parts:
            if isinstance(part, list):
                # Если это список, склеиваем через переносы строк
                prompt_parts.append("\n".join(part))
            else:
                prompt_parts.append(str(part))

    try:
        response = model_obj.generate_content(prompt_parts)
    except Exception as e:
        print(f"Error in model.generate_content: {e}")
        return

    MY_FOLDER_ID = "18Lk31SodxZB3qgZm4ElX3BCejQihreVC"
    file_name = f"report_{section}.txt"
    save_to_drive(file_name, response.text)

#if datetime.today().weekday() == 3:
create_bullets("world")
#  create_bullets("rus")
#  create_bullets("prices")
